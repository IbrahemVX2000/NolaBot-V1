import Canvas from 'canvas';
import { writeFileSync } from 'fs';
import { join } from 'path';

const config = {
    name: "Ø£Ø­Ø¨Ùƒ",
  aliases: ["Ù„ÙˆØ§Ø·","Ø§Ø­Ø¨Ùƒ"],
    description: "",
    usage: "",
    cooldown: 20
}

async function makeImage(data) {
    const { savePath, avatarPathOne, avatarPathTwo } = data;

    try {
        const template = await Canvas.loadImage(join(global.assetsPath, 'love.png'));

        const avatarOne = await Canvas.loadImage(avatarPathOne);
        const avatarTwo = await Canvas.loadImage(avatarPathTwo);

        const avatarOneCircle = await global.circle(avatarOne, avatarOne.width / 2, avatarOne.height / 2, avatarOne.width / 2);
        const avatarTwoCircle = await global.circle(avatarTwo, avatarTwo.width / 2, avatarTwo.height / 2, avatarTwo.width / 2);

        const canvas = new Canvas.createCanvas(template.width, template.height);
        const ctx = canvas.getContext('2d');

        ctx.drawImage(template, 0, 0);
        ctx.drawImage(avatarOneCircle, 338, 205, 211, 211);
        ctx.drawImage(avatarTwoCircle, 562, 210, 211, 211);

        writeFileSync(savePath, canvas.toBuffer());
        return true;
    } catch (e) {
        console.error(e);
        return false;
    }
}

const langData = {
    "ar_SY": {
        "missingTarget": "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¹Ù…Ù„ Ù…Ù†Ø´Ù† Ù„Ù„Ø´Ø®Øµ ",
        "loveMessage": "Ù…Ø¹Ø§ Ù„Ø§Ø¨Ø¯ Ø§Ù„Ø§Ø¨Ø¯ÙŠÙ† ÙŠØ¹Ù…Ø±ÙŠğŸ’•ğŸ’"
    },
    "vi_VN": {
        "missingTarget": "Vui lÃ²ng tag hoáº·c reply má»™t ngÆ°á»i dÃ¹ng",
        "loveMessage": "MÃ£i bÃªn nhau báº¡n nhÃ© <3"
    }
}

async function onCall({ message, getLang }) {
const animeQuestions =["Ø³Ø£Ø¨Ù‚Ù‰ Ø¨Ø¬Ø§Ù†Ø¨Ùƒ ÙˆØ£Ù† Ø§Ù†Ù‚Ù„Ø¨ Ø§Ù„Ø¹Ø§Ù„Ù…ğŸ’•",
                "Ù„Ù† Ø§Ø¬Ø¯ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ù†ÙŠØ§ Ù…Ù† ØªØ·Ù…Ø¦Ù† Ù„Ù‡ Ø±ÙˆØ­ÙŠ ØºÙŠØ±Ùƒ ÙŠØ¹Ù…Ø±ÙŠğŸ¥°",
                "Ø³ÙˆØ§Ø¡Ù‹ ÙƒØ§Ù†Øª Ø§Ù„Ø¯Ù†ÙŠØ§ ØªÙ†Ù‡Ø§Ø± Ø­ÙˆÙ„Ù†Ø§ Ø£Ùˆ ØªØ¹ØµÙ Ø¨Ù†Ø§ Ø§Ù„Ø±ÙŠØ§Ø­ Ø§Ù„Ø¹Ø§ØªÙŠØ©ØŒ ÙØ³ÙˆÙ Ø£Ø¨Ù‚Ù‰ Ø¨Ø¬Ø§Ù†Ø¨Ùƒ Ø¯Ø§Ø¦Ù…Ù‹Ø§ğŸ’",
               "Ø§Ù†Øª ÙˆØ§Ù†Øª ÙÙ‚Ø·ğŸ’ğŸ’•",
               "ÙˆØ§Ù† ÙƒÙ†Øª Ø¨Ø§Ù„Ø¬Ù†Ø© Ù„Ù† ØªÙƒØªÙ…Ù„ ÙØ±Ø­ØªÙŠ Ø§Ù„Ø§ Ø¨ÙˆØ¬ÙˆØ¯ÙƒğŸ’•",
                      "Ù…Ø¹Ø§ Ù„Ø§Ø¨Ø¯ Ø§Ù„Ø§Ø¨Ø¯ÙŠÙ† ÙŠØ¹Ù…Ø±ÙŠğŸ’•ğŸ’"];
  
  const randomIndex = Math.floor(Math.random() * animeQuestions.length);
        const question = animeQuestions[randomIndex];

  
    const { type, messageReply, mentions, senderID } = message;
    let savePath, avatarPathOne, avatarPathTwo;
    try {
        let targetID = type == 'message_reply' ? messageReply.senderID : Object.keys(mentions).length > 0 ? Object.keys(mentions)[0] : senderID;

        if (targetID == senderID) return message.reply(getLang('missingTarget'));

        const selfData = await global.controllers.Users.get(senderID);
        if (!selfData || !selfData.info || !selfData.info.thumbSrc) return;

        const targetData = await global.controllers.Users.get(targetID);
        if (!targetData || !targetData.info || !targetData.info.thumbSrc) return;

        savePath = join(global.cachePath, `love_${targetID}_${Date.now()}.png`);
        avatarPathOne = join(global.cachePath, `rank_avatar_${senderID}_${Date.now()}.jpg`);
        avatarPathTwo = join(global.cachePath, `rank_avatar_${targetID}_${Date.now()}.jpg`);
        await global.downloadFile(avatarPathOne, selfData.info.thumbSrc);
        await global.downloadFile(avatarPathTwo, targetData.info.thumbSrc);

        let result = await makeImage({ savePath, avatarPathOne, avatarPathTwo });

        if (!result) message.reply("Error");
        else await message.reply({ body: question, attachment: global.reader(savePath) });

    } catch (e) {
        console.error(e);
        message.reply("Error");
    }

    if (global.isExists(savePath)) global.deleteFile(savePath);
    if (global.isExists(avatarPathOne)) global.deleteFile(avatarPathOne);
    if (global.isExists(avatarPathTwo)) global.deleteFile(avatarPathTwo);
}

export default {
    config,
    langData,
    onCall
}
